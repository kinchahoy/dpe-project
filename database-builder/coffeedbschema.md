# Coffee DB schema (`coffee.db`)

SQLite database used by the pipeline in `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_db.py`.

## Design intent

- **Single source of truth** for sales events is the `transaction` table.
- Everything else is either:
  - a **dimension table** describing entities (`product`, `machine`, …), or
  - a **derived artifact** (pricing inference, forecasts), or
  - a **view** for convenient “auto-discoverable” daily aggregates and friendly naming.

The DB is optimized for simple analytics + alerting queries (daily rollups, price checks, and short-horizon forecasts).

## Core tables (source-of-truth + dimensions)

### `transaction` (fact table)
One row per vend event.

Key columns:
- `id` (PK)
- `occurred_at` (timestamp), `date` (date bucket)
- `product_id`, `machine_id`, `location_id` (FKs)
- `amount`, `currency`
- `cash_type`, `card_token` (nullable)
- `source_file`, `source_row` (traceability back to `index_*.csv`)

Primary join targets:
- `product` via `transaction.product_id`
- `machine` via `transaction.machine_id`
- `location` via `transaction.location_id`

### `product`
Canonical product names.

- `name` is unique and produced via `product_catalog.canonicalize_product_name()`.

### `ingredient`
Ingredients and their units (e.g. grams, ml).

### `productingredient` (recipe / BOM)
Many-to-many mapping defining recipe quantities:
- (`product_id`, `ingredient_id`) with `quantity`

Used to derive ingredient consumption.

### `machine` and `location`
Where sales occur.

- `machine.location_id` is the machine’s home location.
- `transaction` also stores `location_id` (redundant but convenient for grouping).

## Pricing inference (derived tables)

### `pricechange`
Inferred “price schedule” from transactions, per `(product_id, location_id, currency)`.

Generated by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_price_schedule.py:init_price_schedule()`.

### `transaction_expanded` (derived enrichment table)
One row per `transaction_id` (unique), copying transaction fields plus:
- `expected_price`: expected price for that transaction based on `pricechange` (and optional time-of-day deltas)
- `product_group`: product category from `product_catalog.canonical_product().group`

Generated by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_price_schedule.py:update_expected_prices()`.

Intended use:
- price discrepancy checks: `amount` vs `expected_price`
- grouping by `product_group` without joining to external logic

## Forecast outputs (derived tables)

### `daily_projections`
Daily unit forecasts per `(location_id, machine_id)`:
- includes **per-product rows** (`product_id` set)
- includes a **total row** where `product_id IS NULL` (used as the “total units” forecast)

Generated by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_daily_projections.py:rebuild_daily_projections()`.

### `daily_ingredient_projections`
Ingredient quantity forecasts derived from:
- the “total rows” in `daily_projections` (`product_id IS NULL`)
- observed ingredient-per-transaction rates computed from `transaction` + `productingredient`

Generated by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_daily_ingredient_projections.py:rebuild_daily_ingredient_projections()`.

## Inventory (ops input table)

### `inventory_snapshots`
Start-of-day on-hand quantities per `(machine_id, ingredient_id)` for each `snapshot_date`.

Key columns:
- `snapshot_date` (date)
- `machine_id`, `ingredient_id`
- `quantity_on_hand`, `unit`

Seeded by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/init_inventory_snapshots.py:rebuild_inventory_snapshots()` using a simple heuristic:
- infer typical daily ingredient usage from historical transactions + recipes
- set machine “capacity” to ~5 days of typical use
- assume the machine is fully restocked at the start of each day (so `quantity_on_hand ~= capacity`)

## Views (recommended for analytics)

Views exist to (a) reduce persisted redundant tables and (b) provide friendly names.
They’re created by `/Users/raistlin/code/vr-repos/dpe-project/simple-agent-backend/db.py:create_db()` via `ensure_schema_views()`.

### Friendly alias views (plural names)
- `transactions` → `transaction`
- `products` → `product`
- `ingredients` → `ingredient`
- `machines` → `machine`
- `locations` → `location`
- `product_ingredients` → `productingredient`
- `price_changes` → `pricechange`
- `daily_product_projections` → `daily_projections`

### Derived aggregate views

#### `daily_product_sales`
Daily units sold by:
`(date, location_id, machine_id, product_id, currency, cash_type)`.

#### `daily_ingredient_consumption`
Daily ingredient quantities consumed by:
`(date, machine_id, ingredient_id)`, using recipes from `productingredient`.

### Compatibility views (legacy names)
These exist for older code/query compatibility:
- `dailyproductsales`: same as `daily_product_sales` but **aggregated across machine_id** (historical behavior)
- `dailyingredientconsumption`: alias for `daily_ingredient_consumption`

## “How it’s meant to be used”

Typical alerting/analytics flow:
1. Query `daily_product_sales` for daily product velocity by machine/location.
2. Query `daily_ingredient_consumption` to estimate ingredient drawdown per machine.
3. Query `transaction_expanded` to detect charging anomalies:
   - `expected_price IS NOT NULL AND amount != expected_price`
   - slice by `product_group`, `location_id`, `machine_id`, `cash_type`
4. Use `daily_projections` / `daily_ingredient_projections` to forecast next ~10 days for restock planning.

Regeneration rules:
- `pricechange`, `transaction_expanded`, `daily_projections`, `daily_ingredient_projections` are all **derived** and can be rebuilt from `transaction` + dimension tables.
- `daily_*` aggregates are **views**; they do not need rebuild jobs.
