"""Marimo notebook to view databases generated by the db_init pipeline.

Allows the user to choose a db, a table and view ~20 entries from it.
Primarily for debugging.
"""

import marimo

__generated_with = "0.10.14"
app = marimo.App(width="medium")


@app.cell
def _imports():
    import sys
    from pathlib import Path

    import marimo as mo
    from loguru import logger
    from sqlalchemy import inspect

    # Add project root to path
    PROJECT_ROOT = Path(__file__).resolve().parents[1]
    if str(PROJECT_ROOT) not in sys.path:
        sys.path.insert(0, str(PROJECT_ROOT))

    from db import (
        create_facts_db,
        create_observed_db,
        create_sim_db,
        facts_engine,
        observed_engine,
        sim_engine,
    )

    return (
        mo,
        logger,
        inspect,
        PROJECT_ROOT,
        create_facts_db,
        create_observed_db,
        create_sim_db,
        facts_engine,
        observed_engine,
        sim_engine,
    )


@app.cell
def _initialize_dbs(mo, create_facts_db, create_observed_db, create_sim_db):
    """Initialize all three databases."""
    mo.md(
        "# Database Viewer\n\nView tables and entries from the facts, observed, and sim databases."
    )

    # Initialize databases
    create_facts_db()
    create_observed_db()
    create_sim_db()

    return


@app.cell
def _database_selector(mo, facts_engine, observed_engine, sim_engine):
    """UI to select database."""

    _db_options = {
        "facts": facts_engine,
        "observed": observed_engine,
        "sim": sim_engine,
    }

    database_selector = mo.ui.dropdown(
        options=list(_db_options.keys()),
        value="facts",
        label="Select Database:",
    )

    database_engines = _db_options

    return database_selector, database_engines


@app.cell
def _show_db_selector(mo, database_selector):
    """Display database selector."""
    mo.md(f"### Step 1: Choose a Database\n\n{database_selector}")
    return


@app.cell
def _get_tables(database_selector, database_engines, inspect):
    """Get available tables from selected database."""

    _selected_engine = database_engines[database_selector.value]
    _inspector = inspect(_selected_engine)

    available_tables = sorted(_inspector.get_table_names())

    return (available_tables,)


@app.cell
def _table_selector(mo, available_tables):
    """UI to select table."""

    table_selector = mo.ui.dropdown(
        options=available_tables,
        value=available_tables[0] if available_tables else None,
        label="Select Table:",
    )

    return (table_selector,)


@app.cell
def _show_table_selector(mo, table_selector, available_tables):
    """Display table selector."""
    mo.md(
        f"""
        ### Step 2: Choose a Table

        Available tables: {len(available_tables)}

        {table_selector}
        """
    )
    return


@app.cell
def _query_table(
    mo,
    database_selector,
    database_engines,
    table_selector,
    inspect,
):
    """Query and display entries from selected table using dynamic SQL."""
    from sqlalchemy import text

    # Stop if no table selected
    mo.stop(not table_selector.value)

    _selected_engine = database_engines[database_selector.value]
    _table_name = table_selector.value

    # Build lookup maps for foreign key resolution
    def _build_lookup_maps(conn):
        """Build id->name mappings for common reference tables."""
        _maps = {}

        # Get all available tables across all databases
        _lookup_tables = {
            "product": (database_engines["facts"], "product"),
            "machine": (database_engines["facts"], "machine"),
            "location": (database_engines["facts"], "location"),
            "ingredient": (database_engines["facts"], "ingredient"),
        }

        for _ref_name, (_engine, _table) in _lookup_tables.items():
            try:
                with _engine.connect() as _ref_conn:
                    _ref_result = _ref_conn.execute(
                        text(f'SELECT id, name FROM "{_table}"')
                    )
                    _maps[_ref_name] = {
                        _row[0]: _row[1] for _row in _ref_result.fetchall()
                    }
            except Exception:
                # Table might not exist or have a name column
                _maps[_ref_name] = {}

        return _maps

    # Use raw SQL to query any table dynamically
    with _selected_engine.connect() as _conn:
        _result = _conn.execute(text(f'SELECT * FROM "{_table_name}" LIMIT 20'))
        _columns = list(_result.keys())
        _rows_data = _result.fetchall()

        # Build lookup maps for resolving IDs
        _lookup_maps = _build_lookup_maps(_conn)

    if not _rows_data:
        table_result = mo.md(f"ðŸ“­ Table `{_table_name}` is empty")
    else:
        # Convert to list of dicts for display with resolved names
        _rows = []
        for _row in _rows_data:
            _row_dict = {}
            for _i, _col_name in enumerate(_columns):
                _val = _row[_i]

                # Add the raw value
                _row_dict[_col_name] = str(_val) if _val is not None else ""

                # If this is a foreign key column, try to resolve it
                if _col_name.endswith("_id"):
                    _ref_table = _col_name[:-3]  # Strip '_id' suffix
                    if _ref_table in _lookup_maps and _val in _lookup_maps[_ref_table]:
                        _resolved_name = _lookup_maps[_ref_table][_val]
                        # Add resolved name as additional column
                        _row_dict[f"{_ref_table}_name"] = _resolved_name

            _rows.append(_row_dict)

        table_result = mo.ui.table(
            data=_rows,
            label=f"Table: {_table_name} (showing up to 20 entries)",
        )

    return (table_result,)


@app.cell
def _show_results(mo, table_result, table_selector):
    """Display query results."""
    mo.md(
        f"""
        ### Step 3: View Entries

        Table: **{table_selector.value}**
        """
    )
    return


@app.cell
def _display_table(table_result):
    """Display the table."""
    table_result
    return


if __name__ == "__main__":
    app.run()
