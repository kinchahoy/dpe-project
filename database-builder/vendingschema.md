# Vending machine DB layout (3 SQLite files)

This repo builds three SQLite databases for a vending machine tracker + simulator (stored under `../db/`):

- `../db/vending_machine_facts.db`: **hard facts** (stable dimensions + capacities + recipes)
- `../db/vending_sales_observed.db`: **ingested reality** (transactions + day-level observed rollups)
- `../db/vending_analysis.db`: **ephemeral simulation** (per-run scenario tables + alerts + derived artifacts)

Run `python init_db.py` to rebuild all three from the `index_*.csv` inputs (and the repo’s fact files).

## 1) `vending_machine_facts.db` (hard facts)

Use this when you need the stable definition of the world: what a product is, what ingredients it uses, what machines exist, and what each machine model can hold.

### Core tables

- `location`
  - `external_id` is unique (stable cross-system key)
- `machine`
  - `serial_number` is unique
  - `model` is the join key for capacities
  - `location_id` is the machine’s home location
- `product`
  - `name` is unique and canonicalized (`product_catalog.canonicalize_product_name`)
- `ingredient`
  - `name` is a canonical key like `espresso_shot`, `milk`, `caramel_syrup`
- `product_ingredient`
  - recipe/BOM rows (`product_id`, `ingredient_id`, `quantity`)
- `machine_ingredient_capacity`
  - per **machine model** + ingredient capacity (seeded from `machine_capacities.md`)

## 2) `vending_sales_observed.db` (ingested transactions + daily observed)

Use this when you want “what actually happened” without any simulation assumptions.

### Source-of-truth table

- `transaction`
  - one row per vend
  - contains `product_id`, `machine_id`, `location_id` (these ids refer to facts ids, but are not enforced as FKs)
  - traceability: `source_file`, `source_row`

### Day-level data

- `daily_product_sales` (view)
  - grouped by `(date, location_id, machine_id, product_id, currency, cash_type)`
  - includes `units_sold` and `revenue`
- `daily_ingredient_consumption` (derived table)
  - grouped by `(date, machine_id, ingredient_id)`
  - rebuilt by `init_daily_aggregates.py` from:
    - observed `transaction`
    - facts `product_ingredient` + `ingredient.unit`

## 3) `vending_analysis.db` (ephemeral simulation runs)

Use this when you want a mutable workspace for “what-if” scenarios and per-run outputs.

Every simulation run is anchored by a **seed window** (currently the last 30 days of observed data).

### Run registry

- `sim_run`
  - one row per run (`id` is a UUID string)
  - `seed_start_date`, `seed_end_date`

### Scenario + derived artifacts (per run)

- `sim_price_change`
  - inferred price schedule from the run seed window (and/or scenario edits)
- `sim_transaction_expanded`
  - observed transactions in the seed window enriched with:
    - `expected_price` (from `sim_price_change`)
    - `product_group` (from `product_catalog`)
- `sim_daily_projection`
  - per-run daily unit forecasts (same “top-down mix + total” structure as before)
- `sim_daily_ingredient_projection`
  - ingredient forecasts derived from `sim_daily_projection` totals + observed ingredient rates

### Inventory (interactive app)

Inventory for the interactive manager UI is not stored in `vending_analysis.db`.
It is maintained by the agent app in its own state DB (agent-owned tables), and is
manager-controlled during the simulation (restocks only happen when triggered via
the UI).

### Alerts (per run)

- `sim_alert`
  - stores alerts generated by a separate “ops brain” system
  - includes optional LLM review outputs in the same row (assessment + suggested action)

The suggested-action taxonomy is stored as strings (examples):
- `RESTOCK_MACHINE`
- `ORDER_INGREDIENTS`
- `ADJUST_PRICE`
- `SCHEDULE_SERVICE`
- `CHECK_MACHINE`
- `PROPOSE_DISCONTINUE`

## What to use when

- Need definitions/capacities/recipes: query `vending_machine_facts.db`.
- Need truth data for analytics: query `vending_sales_observed.db` (`transaction`, `daily_product_sales`, `daily_ingredient_consumption`).
- Need mutable scenario state + run outputs + alerts: query `vending_analysis.db`.

## Rebuild rules (keep it simple)

- Rebuild facts when you change:
  - products/recipes (`product_ing.py`)
  - machine capacities (`machine_capacities.md`)
  - machines/locations (placeholder seed in `init_db.py`)
- Rebuild observed when you ingest new `index_*.csv` files.
- Rebuild sim whenever you start a new simulation run (it is intentionally ephemeral).
